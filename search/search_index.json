{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"A Package Factory for Microsoft Intune","text":""},{"location":"#about","title":"About","text":"<p>PSPackageFactory is a fork of IntuneWin32AppPackager combined with Evergreen and VcRedist to create an automated packaging factory for Microsoft Intune.</p> <p>This package factory enables maintaining a library of applications for automatic update, packaging and import into Microsoft Intune. <code>New-Win32Package.ps1</code> uses Evergreen and VcRedist to download the latest version of a target application before packaging and importing into Intune.</p> <p>Evergreen and VcRedist are used to keep the library up to date by updating <code>App.json</code> for each package via a GitHub Workflow that runs once every 24 hours. This ensures that the packaging factory is always current and will create an Intune Win32 application package using the latest available version.</p>"},{"location":"#package-framework","title":"Package Framework","text":"<p>For applications that can't be automatically updated (e.g., installers are locked behind a login, or an installer that is custom to the target environment), this packaging framework can be used as a repeatable process to package and import those applications into Intune.</p> <p>This is important when an application package needs to be updated for a new version of the application. Ensuring that the new package is consistent with previous versions provides consistent deployments.</p>"},{"location":"#features","title":"Features","text":"<p>PSPackageFactory builds on IntuneWin32AppPackager, and adds functionality including:</p> <ul> <li>Supports a library of application packages or application update packages</li> <li>Automatically updates <code>App.json</code> with details of the latest application version</li> <li>Supports icons available over HTTPS - the icon will be downloaded at packaging time</li> <li>Supports additional Win32 application package properties</li> <li>Adds package properties to enable identification of the same application across multiple versions</li> </ul>"},{"location":"app/","title":"About App.json","text":"<p>Each package is defined by <code>App.json</code>. This is largely the same as the original JSON as defined by IntuneWin32AppPackager; however, it has been extended in several key ways.</p> <ol> <li>An <code>Application</code> definition is included that defines details of the target application and how to find the latest version and download URL via Evergreen or VcRedist</li> <li>The <code>PackageInformation.Version</code> value and other locations where the application version is stored, are update automatically when a new version of the application is detected</li> <li>The icon defined in <code>PackageInformation.IconFile</code> can be a HTTP source. <code>Create-Win32App.ps1</code> will attempt to download the icon when creating the application package. An icon library is maintain here: https://github.com/aaronparker/icons/</li> <li>A unique GUID identifier is added to <code>Information.PSPackageFactoryGuid</code> and added to the <code>Notes</code> section of the application in Intune. This is used to link different versions of the same application in Intune. This approach can be used to determine whether an updated version of the application should be imported into Intune</li> <li><code>Dependencies</code>, <code>Supersedence</code>, and <code>Assignments</code> can be added - the intention is to update the package factory to use these values in the future</li> </ol> <p>Info</p> <p>The Package Factory includes a set of applications that are supported for automatic updates via Evergreen and VcRedist. Other applications can be packaged by manually downloading the application installer and updating App.json with the package details.</p> <p>Here's an example <code>App.json</code> for Adobe Acrobat Reader DC:</p> <pre><code>{\n  \"Application\": {\n    \"Name\": \"AdobeAcrobatReaderDC\",\n    \"Filter\": \"Get-EvergreenApp -Name \\\"AdobeAcrobatReaderDC\\\" | Where-Object { $_.Language -eq \\\"MUI\\\" -and $_.Architecture -eq \\\"x64\\\" } | Select-Object -First 1\",\n    \"Title\": \"Adobe Acrobat Reader DC\",\n    \"Language\": \"English\",\n    \"Architecture\": \"x64\"\n  },\n  \"PackageInformation\": {\n    \"SetupType\": \"EXE\",\n    \"SetupFile\": \"AcroRdrDCx642200220191_MUI.exe\",\n    \"Version\": \"22.002.20191\",\n    \"SourceFolder\": \"Source\",\n    \"OutputFolder\": \"Package\",\n    \"IconFile\": \"https://github.com/aaronparker/icons/raw/main/companyportal/Adobe-AcrobatReader.png\"\n  },\n  \"Information\": {\n    \"DisplayName\": \"Adobe Acrobat Reader DC 22.002.20191 x64\",\n    \"Description\": \"The leading PDF viewer to print, sign, and annotate PDFs.\",\n    \"Publisher\": \"Adobe\",\n    \"InformationURL\": \"https://www.adobe.com/acrobat/pdf-reader.html\",\n    \"PrivacyURL\": \"https://www.adobe.com/privacy.html\",\n    \"FeaturedApp\": false,\n    \"Categories\": [],\n    \"PSPackageFactoryGuid\": \"a0042672-7240-4312-892e-39623320c0a3\"\n  },\n  \"Program\": {\n    \"InstallTemplate\": \"powershell.exe -ExecutionPolicy Bypass -NonInteractive -WindowStyle Hidden -File .\\\\Install.ps1\",\n    \"InstallCommand\": \"powershell.exe -ExecutionPolicy Bypass -NonInteractive -WindowStyle Hidden -File .\\\\Install.ps1\",\n    \"UninstallCommand\": \"msiexec.exe /X \\\"{AC76BA86-1033-1033-7760-BC15014EA700}\\\" /quiet\",\n    \"InstallExperience\": \"system\",\n    \"DeviceRestartBehavior\": \"suppress\",\n    \"AllowAvailableUninstall\": false\n  },\n  \"RequirementRule\": {\n    \"MinimumRequiredOperatingSystem\": \"W10_1809\",\n    \"Architecture\": \"x64\"\n  },\n  \"CustomRequirementRule\": [],\n  \"DetectionRule\": [\n    {\n      \"Type\": \"File\",\n      \"DetectionMethod\": \"Version\",\n      \"Path\": \"C:\\\\Program Files\\\\Adobe\\\\Acrobat DC\\\\Acrobat\",\n      \"FileOrFolder\": \"Acrobat.exe\",\n      \"Operator\": \"greaterThanOrEqual\",\n      \"VersionValue\": \"22.002.20191\",\n      \"Check32BitOn64System\": \"false\"\n    }\n  ],\n  \"Dependencies\": [],\n  \"Supersedence\": [],\n  \"Assignments\": []\n}\n</code></pre>"},{"location":"install/","title":"About Install.json","text":"<p>The Packaging Factory implements support for a standardised approach to installing an application via <code>Install.ps1</code>. Using this install script is optional, but it simplifies the maintenance of install scripts by using a single script that reads <code>Install.json</code> that defines the installation logic for an application.</p> <p>The use of <code>Install.ps1</code> is defined in <code>Program.InstallCommand</code> section in the <code>App.json</code> file for each application:</p> <pre><code>  \"Program\": {\n    \"InstallTemplate\": \"powershell.exe -ExecutionPolicy Bypass -NonInteractive -WindowStyle Hidden -File .\\\\Install.ps1\",\n    \"InstallCommand\": \"powershell.exe -ExecutionPolicy Bypass -NonInteractive -WindowStyle Hidden -File .\\\\Install.ps1\",\n    \"UninstallCommand\": \"msiexec.exe /X \\\"{AC76BA86-1033-1033-7760-BC15014EA700}\\\" /quiet\",\n    \"InstallExperience\": \"system\",\n    \"DeviceRestartBehavior\": \"suppress\",\n    \"AllowAvailableUninstall\": false\n  },\n</code></pre> <p>You can replace the installation command with the PowerShell App Deployment Toolkit or directly referencing the application installer; however, <code>Install.ps1</code> provides a simple approach to installing an application while providing some additional features.</p> <p><code>Install.json</code> defines details for the application installer and important install tasks including the application installer silent install arguments:</p> <pre><code>{\n    \"PackageInformation\": {\n        \"SetupType\": \"EXE\",\n        \"SetupFile\": \"AcroRdrDCx642200220191_MUI.exe\",\n        \"Version\": \"22.002.20191\"\n    },\n    \"LogPath\": \"C:\\\\ProgramData\\\\Microsoft\\\\IntuneManagementExtension\\\\Logs\",\n    \"InstallTasks\": {\n        \"ArgumentList\": \"-sfx_nu /sALL /rps /l /msi EULA_ACCEPT=YES ENABLE_CHROMEEXT=0 DISABLE_BROWSER_INTEGRATION=1 ENABLE_OPTIMIZATION=YES ADD_THUMBNAILPREVIEW=0 DISABLEDESKTOPSHORTCUT=1 /log \\\"#LogPath\\\\#LogName.log\\\"\"\n    },\n    \"PostInstall\": {\n        \"Remove\": [\n        ],\n        \"CopyFile\": [\n        ]\n    }\n}\n</code></pre> <p>Like <code>App.json</code>, <code>Install.json</code> is also automatically updated with application information returned from Evergreen, including the installer file name and the application version number. By updating the <code>PackageInformation.SetupFile</code> information in <code>Install.json</code>, we ensure that <code>Install.ps1</code> will look for that specific installer file and not attempt to execute any other file.</p>"},{"location":"install/#psappdeploytoolkit","title":"PSAppDeployToolkit","text":"<p>If you prefer to use the PSAppDeployToolkit, replace <code>Install.json</code> with <code>Invoke-AppDeployToolkit.ps1</code>. When <code>New-Win32Package.ps1</code> is run, it will detect the presence of <code>Invoke-AppDeployToolkit.ps1</code> and copy the PSAppDeployToolkit into the package before preparing the .intunewin file.</p>"},{"location":"intunewin32/","title":"IntuneWin32AppPackager Framework Overview","text":"<p>IntuneWin32AppPackager aims at making it easier to package, create and at the same time document Win32 applications for Microsoft Intune. A manifest file named <code>App.json</code> needs to be configured to control how the application is created. Configurations such as application name, description, requirement rules, detection roles and other is defined within the manifest file. <code>Create-Win32App.ps1</code> is used to start the creation of the application, based upon configurations specified in the manifest file, <code>App.json</code>.</p>"},{"location":"intunewin32/#file-and-folder-structure","title":"File and folder structure","text":"<p>For each application that has to be packaged as a Win32 app, a specific application folder should be created with the IntuneWin32AppPackager files and folder residing inside it. Below is an example of how the folder structure could look like:</p> <ul> <li>Root</li> <li>Application 1.0.0 (Folder where the IntuneWin32AppPackager is contained within)<ul> <li>Package (Folder)</li> <li>Source (Folder)</li> <li>Scripts (Folder)</li> <li>Icon.png (this can also be a HTTP reference)</li> <li>App.json</li> </ul> </li> </ul>"},{"location":"intunewin32/#package-folder","title":"Package folder","text":"<p>A required folder where the packaged .intunewin file will be created in after execution of <code>Create-Win32App.ps1</code>.</p>"},{"location":"intunewin32/#source-folder","title":"Source folder","text":"<p>A required folder that must contain the source files, meaning everything that's supposed to be packaged as a .intunewin file, else the packaging will fail if empty.</p>"},{"location":"intunewin32/#scripts-folder","title":"Scripts folder","text":"<p>Use this folder for any custom created scripts used for either Requirement Rules or Detection Rules. This folder is only required when such custom script files are used.</p>"},{"location":"intunewin32/#create-win32appps1-script","title":"Create-Win32App.ps1 script","text":"<p>Main framework script that packages, retrieves the required information from the manifest file and constructs necessary objects that are passed on to <code>Add-IntuneWin32App</code> function from the IntuneWin32App module. This script has a -Validate switch that can be used to validate the manifest file configuration, which results in that the configuration is written as output to the console instead of creating a new Win32 application.</p>"},{"location":"intunewin32/#first-things-first","title":"First things first","text":"<p>Using this Win32 application packaging framework requires the IntuneWin32App module, minimum version <code>1.3.3</code>, to be installed on the device where it's executed. Install the module from the PSGallery using:</p> <pre><code>Install-Module -Name IntuneWin32App\n</code></pre>"},{"location":"intunewin32/#manifest-configuration-appjson","title":"Manifest configuration (App.json)","text":"<p>Within the manifest file, there are several segments of configuration that controls different parts in the packaging framework. Below are sample configurations for each segment including their possible values. Since the manifest file is written in JSON, there's no built in commenting support system. Segments consists of static properties, such as PackageInformation for instance. Static properties within the manifest file should never be changed. Sub-properties such as <code>SetupType</code> for instance, are referred to as dynamic properties (meaning that they are named differently depending on the configuration scenario, e.g. MSI or EXE, or a detection rule based on a script or registry key). Some dynamic properties have a set of pre-defined values which can be used. Such dynamic properties are documented with their possible values, for instance as shown below:</p> <pre><code>\"DeviceRestartBehavior\": \"suppress \\\\ force \\\\ basedOnReturnCode \\\\ allow\"\n</code></pre> <p>Each possible value are separated with the '\\' character, where the desired value are kept and the rest are simply removed.</p>"},{"location":"intunewin32/#packageinformation","title":"PackageInformation","text":"<p>Below block is the main information related to the packaging of a Win32 app, like the setup file, content source folder and output folder for the .intunewin file, but it also contains other information such as the icon file to use and last but not least, the overall packaging method as either EXE or MSI.</p> <pre><code>\"PackageInformation\": {\n    \"SetupType\": \"MSI \\\\ EXE\",\n    \"SetupFile\": \"Setup.exe\",\n    \"SourceFolder\": \"Source\",\n    \"OutputFolder\": \"Package\",\n    \"IconFile\": \"Icon.png\"\n}\n</code></pre>"},{"location":"intunewin32/#information","title":"Information","text":"<p>This block contains the basic Win32 app information, such as the display name, description and publisher. All properties are required to have a value, with an exception for the Notes property.</p> <pre><code>\"Information\": {\n    \"DisplayName\": \"AppName 1.0.0\",\n    \"Description\": \"Installs AppName 1.0.0\",\n    \"Publisher\": \"AppVendor\"\n}\n</code></pre>"},{"location":"intunewin32/#program","title":"Program","text":"<p>This block contains the desired program information of a Win32 app. InstallCommand and UninstallCommand are only required when <code>SetupType</code> in the PackageInformation section is set to EXE, otherwise the packaging creation process will automatically construct the installation and uninstallation commands for MSI installations. In addition to this, the install experience, for the installation to run in either System or User context including the restart behavior are specified here.</p> <pre><code>\"Program\": {\n    \"InstallCommand\": \"&lt;-- Only required when SetupType is set as EXE --&gt;\",\n    \"UninstallCommand\": \"&lt;-- Only required when SetupType is set as EXE --&gt;\",\n    \"InstallExperience\": \"system \\\\ user\",\n    \"DeviceRestartBehavior\": \"suppress \\\\ force \\\\ basedOnReturnCode \\\\ allow\",\n    \"AllowAvailableUninstall\": false \\\\ true\n}\n</code></pre>"},{"location":"intunewin32/#detectionrule","title":"DetectionRule","text":"<p>As you may know, the Win32 app model provides several methods on detecting if the application is or have already been installed. IntuneWin32AppPackager framework supports all potential detection rules, such as MSI, File, Registry or Script based. It's supported to add multiple detection rules can be added to the manifest file.</p> <p>NOTE: It's not supported to add multiple detection rules when a Script detection rule is used.</p>"},{"location":"intunewin32/#detectionrule-registry","title":"DetectionRule - Registry","text":"<p>A Registry detection rule type can be of different detection methods, such as:</p> <ul> <li>Existence</li> <li>IntegerComparison</li> <li>StringComparison</li> <li>VersionComparison</li> </ul> <p>Below are example configurations for each supported detection method for a Registry detection rule.</p>"},{"location":"intunewin32/#detectionrule-registry-existence","title":"DetectionRule - Registry - Existence","text":"<pre><code>{\n    \"Type\": \"Registry\",\n    \"DetectionMethod\": \"Existence\",\n    \"KeyPath\": \"HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Key\",\n    \"ValueName\": \"DisplayVersion\",\n    \"DetectionType\": \"exists \\\\ notExists\",\n    \"Check32BitOn64System\": \"false \\\\ true\"\n}\n</code></pre>"},{"location":"intunewin32/#detectionrule-registry-integercomparison","title":"DetectionRule - Registry - IntegerComparison","text":"<pre><code>{\n    \"Type\": \"Registry\",\n    \"DetectionMethod\": \"IntegerComparison\",\n    \"KeyPath\": \"HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Key\",\n    \"ValueName\": \"DisplayVersion\",\n    \"Operator\": \"notEqual \\\\ lessThanOrEqual \\\\ lessThan \\\\ greaterThanOrEqual \\\\ greaterThan \\\\ equal\",\n    \"Value\": \"1\",\n    \"Check32BitOn64System\": \"false \\\\ true\"\n}\n</code></pre>"},{"location":"intunewin32/#detectionrule-registry-stringcomparison","title":"DetectionRule - Registry - StringComparison","text":"<pre><code>{\n    \"Type\": \"Registry\",\n    \"DetectionMethod\": \"StringComparison\",\n    \"KeyPath\": \"HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Key\",\n    \"ValueName\": \"DisplayVersion\",\n    \"Operator\": \"notEqual \\\\ equal\",\n    \"Value\": \"1.0.0\",\n    \"Check32BitOn64System\": \"false \\\\ true\"\n}\n</code></pre> <p>More: Registry - StringComparison</p> <pre><code>{\n    \"Type\": \"Registry\",\n    \"DetectionMethod\": \"VersionComparison\",\n    \"KeyPath\": \"HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Key\",\n    \"ValueName\": \"DisplayVersion\",\n    \"Operator\": \"notEqual \\\\ lessThanOrEqual \\\\ lessThan \\\\ greaterThanOrEqual \\\\ greaterThan \\\\ equal\",\n    \"Value\": \"1.0.0\",\n    \"Check32BitOn64System\": \"false \\\\ true\"\n}\n</code></pre>"},{"location":"intunewin32/#detectionrule-file","title":"DetectionRule - File","text":"<p>A File detection rule type can be of different detection methods, such as:</p> <ul> <li>Existence</li> <li>DateModified</li> <li>DateCreated</li> <li>Version</li> <li>Size</li> </ul> <pre><code>{\n    \"Type\": \"Registry\",\n    \"DetectionMethod\": \"VersionComparison\",\n    \"KeyPath\": \"HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Uninstall\\\\123\",\n    \"ValueName\": \"DisplayVersion\",\n    \"Operator\": \"greaterThanOrEqual\",\n    \"Value\": \"1.0.0\",\n    \"Check32BitOn64System\": \"false\"\n}\n</code></pre>"},{"location":"intunewin32/#msi-example-manifest","title":"MSI Example manifest","text":"<pre><code>{\n    \"PackageInformation\": {\n        \"SetupType\": \"MSI\",\n        \"SetupFile\": \"7z1900-x64.msi\",\n        \"SourceFolder\": \"Source\",\n        \"OutputFolder\": \"Package\",\n        \"IconFile\": \"Icon.png\"\n    },\n    \"Information\": {\n        \"DisplayName\": \"7-Zip 19.0 x64\",\n        \"Description\": \"Install 7-Zip archive compression application\",\n        \"Publisher\": \"7-Zip\",\n        \"Notes\": \"Core application\"\n    },\n    \"Program\": {\n        \"InstallExperience\": \"system\",\n        \"DeviceRestartBehavior\": \"suppress\"\n    },\n    \"RequirementRule\": {\n        \"MinimumRequiredOperatingSystem\": \"W10_1809\",\n        \"Architecture\": \"x64\"\n    },\n    \"CustomRequirementRule\": [\n    ],\n    \"DetectionRule\": [\n        {\n            \"Type\": \"MSI\",\n            \"ProductCode\": \"{23170F69-40C1-2702-1900-000001000000}\",\n            \"ProductVersionOperator\": \"notConfigured\",\n            \"ProductVersion\": \"\"\n        }\n    ]\n}\n</code></pre>"},{"location":"logging/","title":"Application Install Logging","text":"<p>The PSPackageFactory supports logging in two primary locations so that you can retrieve logs for troubleshooting. Logs are stored in the Intune Management Extension logs directory for a consistent location.</p> <ul> <li><code>C:\\ProgramData\\Microsoft\\IntuneManagementExtension\\Logs\\PSPackageFactoryInstall.log</code> - <code>Install.ps1</code> will write install actions to this log</li> <li><code>C:\\ProgramData\\Microsoft\\IntuneManagementExtension\\Logs\\&lt;application&gt;.log</code> - where supported, application installers will write a specific installation log to this location</li> </ul> <p></p>"},{"location":"pipeline/","title":"Use in a Pipeline","text":"<p>Using the package factory in a pipeline requires a Windows runner. The pipeline will run the same process as if the factory was running on a local machine.</p>"},{"location":"pipeline/#powershell-modules","title":"PowerShell Modules","text":"<p>The factory requires that the MSAL.PS, IntuneWin32App, Evergreen, VcRedist PowerShell modules are installed. Install with the following command:</p> <pre><code>Install-Module -Name \"MSAL.PS\", \"IntuneWin32App\", \"Evergreen\", \"VcRedist\" -Force -SkipPublisherCheck\n</code></pre>"},{"location":"pipeline/#authentication","title":"Authentication","text":"<p><code>Connect-MSIntuneGraph</code> can authenticate to an app registration by passing the tenant ID, application (or client) ID and the client secret:</p> <pre><code>$params = @{\n  TenantId     = \"$env:TENANT_ID\"\n  ClientId     = \"$env:CLIENT_ID\"\n  ClientSecret = \"$env:CLIENT_SECRET\"\n}\nConnect-MSIntuneGraph @params\n</code></pre>"},{"location":"pipeline/#create-an-application-package","title":"Create an Application Package","text":"<p><code>New-Win32Package.ps1</code> is used to read the application package manifest, create the Intune Win32 package and call <code>Create-Win32App.ps1</code> to import the package into the target Intune tenant.</p> <p>Here's an example with importing Adobe Acrobat Reader DC and Citrix Workspace app into your Intune tenant by passing an array of package names to the <code>-Application</code> parameter:</p> <pre><code>$params = @{\n    Path        = \"E:\\projects\\packagefactory\\packages\"\n    Application = \"AdobeAcrobatReaderDCMUI\", \"CitrixWorkspaceApp\"\n    Type        = \"App\"\n    WorkingPath = \"E:\\projects\\packagefactory\\output\"\n    Import      = $true\n}\n.\\New-Win32Package.ps1 @params\n</code></pre>"},{"location":"pipeline/#create-an-update-package","title":"Create an Update Package","text":"<p><code>New-Win32Package.ps1</code> can also create update packages where an application update is defined. The usage is exactly the same (because the update package logic is stored in the <code>App.json</code> for that package) - pass the package name to the <code>-Application</code> parameter, but also specify Update for the <code>-Type</code> parameter.</p> <p>Here's an example with importing a Adobe Acrobat Reader DC update into your Intune tenant:</p> <pre><code>Set-Location -Path \"E:\\projects\\packagefactory\"\n$params = @{\n    Path        = \"E:\\projects\\packagefactory\\packages\"\n    Application = \"AdobeAcrobatReaderDCMUIx64\"\n    Type        = \"Update\"\n    WorkingPath = \"E:\\projects\\packagefactory\\output\"\n    Import      = $true\n}\n.\\New-Win32Package.ps1 @params\n</code></pre>"},{"location":"setup/","title":"Set Up the Packaging Factory","text":"<p>Running the packaging factory locally requires a support version of Windows because the Microsoft Win32 Content Prep Tool runs on Windows only. Additionally, the packaging factory has only been tested on Windows PowerShell. It may run on PowerShell 7; however, it is not actively tested on that version of PowerShell.</p>"},{"location":"setup/#install-the-required-powershell-modules","title":"Install the required PowerShell modules","text":"<p>Install the required PowerShell modules. IntuneWin32 (which depends on MSAL.PS), Evergreen and VcRedist are required modules.</p> <pre><code>Install-Module -Name IntuneWin32App, Evergreen, VcRedist, MSAL.PS\n</code></pre> <p>It is always worth ensuring you are running the latest version of each module:</p> <pre><code>Update-Module -Name IntuneWin32App, Evergreen, VcRedist, MSAL.PS\nImport-Module -Name IntuneWin32App, Evergreen, VcRedist, MSAL.PS -Force\n</code></pre>"},{"location":"setup/#download-the-packaging-factory","title":"Download the Packaging Factory","text":"<p>Clone the packaging factory - you can download the zip file containing the entire repository; however, to ensure your local copy can be updated with changes to the source repository, it will be easier to clone the repository with git git.</p> <p>Git can be installed easily with winget:</p> <pre><code>winget install Git.Git\n</code></pre> <p>With git installed, you can clone the repository into a target directory (e.g. <code>E:\\projects\\packagefactory</code>) with the following commands:</p> <pre><code>New-Item -Path \"E:\\projects\" -ItemType \"Directory\"\nSet-Location -Path \"E:\\projects\"\ngit clone https://github.com/aaronparker/packagefactory.git\n</code></pre>"},{"location":"setup/#keeping-in-sync-with-the-package-factory","title":"Keeping in sync with the Package Factory","text":"<p>After creating application packages with the package factory, you will have additional files downloaded including icons and installers in your cloned directory. To reset the package factory back to defaults and synchronise your copy with the source repository, you can reset your local changes and download new changes with:</p> <pre><code>git clean -f\ngit restore .\ngit pull\n</code></pre>"},{"location":"setup/#gui-tools","title":"GUI Tools","text":"<p>If you aren't comfortable with the command-line instructions above, there are GUI-based git tools available that can simplify cloning the repository and managing your local copy. We recommend using:</p> <ul> <li>GitHub Desktop; or</li> <li>Fork</li> </ul>"},{"location":"use/","title":"Importing Packages on Windows","text":"<p>To run the package factory locally, clone the repository to a Windows machine, and install the required PowerShell modules.</p>"},{"location":"use/#powershell-modules","title":"PowerShell Modules","text":"<p>The factory requires that the MSAL.PS, IntuneWin32App, Evergreen, VcRedist PowerShell modules are installed. Ensure you have setup your environment before attempting to create packages.</p>"},{"location":"use/#authentication","title":"Authentication","text":"<p>When running the packaging factory locally on Windows to create application packages and import into an Intune tenant, you must first authenticate to the tenant. The user account used to authenticate must be an Intune Administrator or an Intune Application manager.</p>"},{"location":"use/#interactive-authentication","title":"Interactive Authentication","text":"<p>Interactive authentication to a tenant can be performed with <code>Connect-MSIntuneGraph</code>:</p> <pre><code>Connect-MSIntuneGraph -TenantId stealthpuppylab.onmicrosoft.com\n</code></pre> <p>This will launch a sign-in window where you can authenticate with an account that has at least the Intune Administrator role. Note that Microsoft Intune PowerShell application is required. Access to this application must be granted by a global administrator.</p> <p> </p>"},{"location":"use/#authentication-via-an-app-registration","title":"Authentication via an App Registration","text":"<p><code>Connect-MSIntuneGraph</code> can authenticate to an app registration by passing the tenant ID, application (or client) ID and the client secret:</p> <pre><code>$params = @{\n    TenantId     = \"6cdd8179-23e5-43d1-8517-b6276a8d3189\"\n    ClientId     = \"60912c81-37e8-4c94-8cd6-b8b90a475c0e\"\n    ClientSecret = \"&lt;secret&gt;\"\n}\nConnect-MSIntuneGraph @params\n</code></pre> <p>The app registration requires the following API permissions:</p> API / Permissions name Type Description Admin consent required DeviceManagementApps.ReadAll Application Read Microsoft Intune apps Yes DeviceManagementApps.ReadWriteAll Application Read and write Microsoft Intune apps Yes"},{"location":"use/#parameters","title":"Parameters","text":"<p><code>New-Win32Package.ps1</code> has several parameters:</p> <ul> <li><code>-Path</code> - The literal path to the packages directory within the downloaded project. This defaults to the same directory as where <code>New-Win32Package.ps1</code> is located</li> <li><code>-PackageManifest</code> - The package manifest file name stored in each package directory. This defaults to <code>App.json</code> and does not need to be specified</li> <li><code>-InstallScript</code> - The template install script file name that will be copied into the package. This parameter does not need to be specified and should not be changed</li> <li><code>-Application</code> - An array of application names to import into the target Intune tenant. The application names must match those applications stored in the project</li> <li><code>-Type</code> - The package type to import into the target Intune tenant - App or Update. The array passed to Applications must match those application packages defined for this type.</li> <li><code>-WorkingPath</code> - Path to a working directory used when creating the Intunewin packages. This defaults to a directory named <code>output</code> in the project directory and does not need to be specified; however, you can choose to provide a working directory in an alternative location</li> <li><code>-Import</code> - Imports the package into the target Intune tenant. If this switch is not specified, the package will be not be imported</li> <li><code>Force</code> - Create the package, even if a matching version already exists.</li> <li><code>Certificate</code>- Specifies the certificate that will be used to sign the script or file. Enter a variable that stores an object representing the certificate. Used by Set-AuthenticodeSignature.</li> <li><code>CertificateSubject</code> - Specifies the certificate subject name that will be used to sign scripts. Used by Set-AuthenticodeSignature.</li> <li><code>CertificateThumbprint</code> - Specifies the certificate thumbprint that will be used to sign scripts. Used by Set-AuthenticodeSignature.</li> <li><code>TimestampServer</code>- Uses the specified time stamp server to add a time stamp to the signature. Type the URL of the time stamp server as a string. The URL must start with https:// or http://. Used by Set-AuthenticodeSignature.</li> <li><code>IncludeChain</code> - Determines which certificates in the certificate trust chain are included in the digital signature. NotRoot is the default. Used by Set-AuthenticodeSignature.</li> </ul>"},{"location":"use/#create-an-application-package","title":"Create an Application Package","text":"<p><code>New-Win32Package.ps1</code> is used to read the application package manifest, create the Intune Win32 package and call <code>Create-Win32App.ps1</code> to import the package into the target Intune tenant. The value passed to the <code>-Application</code> parameter must match a supported application package in the App directory.</p> <p>Here's an example with importing Adobe Acrobat Reader DC and Citrix Workspace app into your Intune tenant by passing an array of package names to the <code>-Application</code> parameter:</p> <pre><code>Set-Location -Path \"E:\\projects\\packagefactory\"\n$params = @{\n    Path        = \"E:\\projects\\packagefactory\\packages\"\n    Application = \"AdobeAcrobatReaderDCMUI\", \"CitrixWorkspaceApp\"\n    Type        = \"App\"\n    WorkingPath = \"E:\\projects\\packagefactory\\output\"\n    Import      = $true\n}\n.\\New-Win32Package.ps1 @params\n</code></pre>"},{"location":"use/#create-an-update-package","title":"Create an Update Package","text":"<p><code>New-Win32Package.ps1</code> can also create update packages where an application update is defined. The usage is exactly the same (because the update package logic is stored in the <code>App.json</code> for that package) - pass the package name to the <code>-Application</code> parameter, but also specify Update for the <code>-Type</code> parameter. The value passed to the <code>-Application</code> parameter must match a supported application package in the Update directory.</p> <p>Here's an example with importing a Adobe Acrobat Reader DC update into your Intune tenant:</p> <pre><code>Set-Location -Path \"E:\\projects\\packagefactory\"\n$params = @{\n    Path        = \"E:\\projects\\packagefactory\\packages\"\n    Application = \"AdobeAcrobatReaderDCMUIx64\"\n    Type        = \"Update\"\n    WorkingPath = \"E:\\projects\\packagefactory\\output\"\n    Import      = $true\n}\n.\\New-Win32Package.ps1 @params\n</code></pre>"},{"location":"use/#signing-scripts-in-packages","title":"Signing Scripts in Packages","text":"<p><code>New-Win32Package.ps1</code> supports signing PowerShell scripts in the application package. This requires a code signing certificate and will sign all PowerShell scripts in the package (including the PSAppDeployToolkit, if used). For information about using code signing certificates with Intune, refer to this article: Adding a Certificate to Trusted Publishers using Microsoft Intune.</p> <p>There are several ways to specify a code signing certificate to use when creating the package. The code signing certificate can be specified by first retrieving the certificate from the certificate store:</p> <pre><code>$Certificate = Get-ChildItem -Path \"Cert:\\CurrentUser\\My\" | Where-Object { $_.Subject -eq \"CN=stealthpuppy Lab code signing certificate\" }\nSet-Location -Path \"E:\\projects\\packagefactory\"\n$params = @{\n    Path        = \"E:\\projects\\packagefactory\\packages\"\n    Application = \"AdobeAcrobatReaderDCMUIx64\"\n    Type        = \"Update\"\n    WorkingPath = \"E:\\projects\\packagefactory\\output\"\n    Import      = $true\n    Certificate  = $Certificate\n}\n.\\New-Win32Package.ps1 @params\n</code></pre> <p>The certificate subject name can be specified and <code>New-Win32Package.ps1</code> will retrieve the certificate for you:</p> <pre><code>Set-Location -Path \"E:\\projects\\packagefactory\"\n$params = @{\n    Path              = \"E:\\projects\\packagefactory\\packages\"\n    Application       = \"AdobeAcrobatReaderDCMUIx64\"\n    Type              = \"Update\"\n    WorkingPath       = \"E:\\projects\\packagefactory\\output\"\n    Import            = $true\n    CertificateSubject = \"CN=stealthpuppy Lab code signing certificate\"\n}\n.\\New-Win32Package.ps1 @params\n</code></pre> <p>Or, the certificate thumbprint can be specified and <code>New-Win32Package.ps1</code> will retrieve the certificate for you:</p> <pre><code>Set-Location -Path \"E:\\projects\\packagefactory\"\n$params = @{\n    Path                 = \"E:\\projects\\packagefactory\\packages\"\n    Application          = \"AdobeAcrobatReaderDCMUIx64\"\n    Type                 = \"Update\"\n    WorkingPath          = \"E:\\projects\\packagefactory\\output\"\n    Import               = $true\n    CertificateThumbprint = \"5CD18CE3DBD91FCBB5ABB4775DBE1E79110FD6B8\"\n}\n.\\New-Win32Package.ps1 @params\n</code></pre>"}]}